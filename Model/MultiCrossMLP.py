import joblib
import torch
import torch.nn as nn
from einops.layers.torch import Rearrange
from torchvision.ops import MLP
from sklearn.ensemble import RandomForestClassifier
from sklearn.neighbors import KNeighborsClassifier

class MultiCrossMLP(nn.Module):
    def __init__(self, dim, hiddenDim, numGroups):
        super(MultiCrossMLP, self).__init__()

        self.numGroups = numGroups
        self.initDense = nn.Linear(dim, hiddenDim)
        self.groupSplit = Rearrange('b (g d) -> b g d', g = numGroups)
        
        groupDim = hiddenDim // numGroups
        self.MLPs = nn.ModuleList([MLP(in_channels=groupDim, hidden_channels=[groupDim * 2, groupDim * 4, groupDim * 8],
                                       norm_layer=nn.LayerNorm, activation_layer=nn.GELU)] * numGroups)
        self.RFs = [RandomForestClassifier(n_estimators=10, criterion='entropy',
                                           max_depth=5, min_samples_split=3, min_samples_leaf=3, random_state=194, n_jobs=-1)] * numGroups
        self.KNNs = [KNeighborsClassifier(n_neighbors=5, n_jobs=-1)] * numGroups
        
        outMLPDim = groupDim * 8 * numGroups
        self.classifier = nn.Sequential(
            MLP(in_channels=outMLPDim, hidden_channels=[outMLPDim // 10, outMLPDim // 20, outMLPDim // 30], 
                norm_layer=nn.LayerNorm, activation_layer=nn.GELU),
            nn.Linear(outMLPDim // 30, 1),
            nn.Sigmoid(),
        )

    def saveWeightModule(self, RFdir, KNNdir):
        for group in range(0, self.numGroups):
             joblib.dump(self.RFs[group], f"{RFdir}/Group{group}.ckpt", compress=3)
             joblib.dump(self.KNNs[group], f"{KNNdir}/Group{group}.ckpt", compress=3)

        return
    
    def loadWeightModule(self, RFdir, KNNdir):
        for group in range(0, self.numGroups):
             self.RFs[group] = joblib.load(f"{RFdir}/Group{group}.ckpt")
             self.KNNs[group] = joblib.load(f"{KNNdir}/Group{group}.ckpt")

        return

    def forward(self, x, y=None):
        x = self.initDense(x)
        x = self.groupSplit(x)

        mergeFeatures = torch.tensor([], requires_grad=True)
        totalPredictRF = torch.tensor([], requires_grad=True)
        totalPredictKNN = torch.tensor([], requires_grad=True)
        for group in range(0, self.numGroups):
            input = x[:, group, :].detach()
            outputMLP = self.MLPs[group](input)
            if self.training:
                self.RFs[group] = self.RFs[group].fit(input.detach().numpy(), y.detach().numpy())
                self.KNNs[group] = self.KNNs[group].fit(input.detach().numpy(), y.detach().numpy())

            outputRF = self.RFs[group].predict(input.detach().numpy())
            outputRF = torch.tensor(outputRF, dtype=float).unsqueeze(1)

            outputKNN = self.KNNs[group].predict(input.detach().numpy())
            outputKNN = torch.tensor(outputKNN, dtype=float).unsqueeze(1)

            totalPredictRF = torch.cat((totalPredictRF, outputRF), 1)
            totalPredictKNN = torch.cat((totalPredictKNN, outputKNN), 1)
            mergeFeatures = torch.cat((mergeFeatures, outputMLP), 1)

        totalPredictRF = totalPredictRF.mean(dim=1)
        totalPredictKNN = totalPredictKNN.mean(dim=1)
        totaPredictlMLP = torch.tensor([1. if p >= 0.5 else 0. for p in self.classifier(mergeFeatures)], dtype=float, requires_grad=True)

        out = torch.stack((totaPredictlMLP, totalPredictRF, totalPredictKNN), dim=1).mean(dim=1)
        return out
    
if __name__ == '__main__':
    inp = torch.rand(32, 114)
    model = MultiCrossMLP(114, 250, 10)
    out = model(inp)
    print(out)